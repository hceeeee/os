# 实验3：页表与内存管理 - 实现说明

## 一、整体架构

实验3包含三个核心模块：
1. **物理内存管理器 (PMM)** - 管理物理页面分配/释放
2. **页表管理系统** - 实现Sv39 3级页表结构
3. **内核虚拟内存初始化** - 创建并激活内核页表

## 二、核心实现原理

### 1. 物理内存管理器 (pmm.c)

**设计思路**：
- 使用静态内存池，简单可靠
- 栈式分配：O(1)时间复杂度
- 只支持页级分配，避免碎片

**关键数据结构**：
```c
static unsigned char memory_pool[MAX_PAGES * PAGE_SIZE];  // 静态内存池
static void *free_list[MAX_PAGES];  // 空闲页栈
static int free_count = 0;  // 栈顶索引
```

**核心函数**：
- `alloc_page()`: 从栈顶弹出页面，清零后返回
- `free_page()`: 安全检查后压入空闲栈
- `alloc_pages(n)`: 分配n个页面，失败时回滚

### 2. 页表管理系统 (pagetable.c)

**Sv39页表结构**：
```
虚拟地址 (39位) = VPN[2](9位) + VPN[1](9位) + VPN[0](9位) + 偏移(12位)
```

**三级页表树**：
```
Level 2 (Root)  ->  512个PTE
    |
    +-> Level 1  ->  512个PTE
        |
        +-> Level 0  ->  512个PTE -> 物理页
```

**核心函数**：
- `walk_create()`: 遍历并创建中间页表（用于建立映射）
- `walk_lookup()`: 遍历查找（不创建），用于查找映射
- `map_page()`: 建立VA到PA的映射，自动创建中间表

**地址解析示例**：
```
VA = 0x40000000
VPN[2] = (0x40000000 >> 30) & 0x1FF = 1
VPN[1] = (0x40000000 >> 21) & 0x1FF = 0
VPN[0] = (0x40000000 >> 12) & 0x1FF = 0
```

### 3. 内核虚拟内存初始化 (kvminit.c)

**映射策略（恒等映射，VA=PA）**：

1. **内核代码段** (`_text` - `_etext`)
   - 权限：R|X（可读可执行）
   - 为什么需要：CPU需要执行指令

2. **只读数据段** (`_rodata` - `_erodata`)
   - 权限：R（只读）
   - 为什么需要：常量数据保护

3. **数据+BSS段** (`_data` - `_end`)
   - 权限：R|W（可读可写）
   - 为什么需要：全局变量存储

4. **额外物理内存**
   - 权限：R|W
   - 为什么需要：内核动态分配

5. **设备区域** (UART: 0x10000000)
   - 权限：R|W
   - 为什么需要：访问硬件设备

**启用分页流程**：
```c
void kvminithart(void) {
    // 1. 构建SATP值
    uint64_t satp = MAKE_SATP(kernel_pagetable);
    // SATP = MODE(8) << 60 | PPN >> 12
    
    // 2. 写SATP寄存器
    w_satp(satp);  // csrw satp, %0
    
    // 3. 刷新TLB
    sfence_vma();  // 使新设置生效
}
```

**SATP寄存器格式**：
```
[63:60] MODE:  8 = Sv39分页模式
[59:44] ASID: 0 = 地址空间ID（未使用）
[43:0]  PPN:  页表物理页号
```

## 三、关键设计决策

### 1. 为什么使用静态内存池？
- **简单可靠**：不需要复杂的空闲链表
- **适合实验**：固定64页足够测试
- **快速分配**：O(1)时间复杂度

### 2. 为什么只支持页级分配？
- **避免碎片**：4KB固定大小，无需考虑碎片合并
- **简化实现**：不需要buddy system或slab分配器
- **符合页表需求**：页表本身就是4KB对齐

### 3. 为什么使用恒等映射？
- **简化设置**：VA=PA，减少计算
- **避免立即失败**：启用分页后代码继续在相同地址执行
- **内核习惯**：内核代码期望直接物理地址

### 4. 为什么需要`walk_create`和`walk_lookup`分离？
- **不同用途**：
  - `walk_create`: 建立映射时用（需要创建中间表）
  - `walk_lookup`: 查找映射时用（只读，不创建）
- **性能优化**：查找不需要分配内存

## 四、测试验证

### 测试1：物理内存管理
- 测试分配/释放
- 测试页对齐
- 测试读写功能
- 测试分配失败回滚

### 测试2：页表管理
- 测试创建页表
- 测试建立映射
- 测试查找映射
- 测试权限控制

### 测试3：虚拟内存激活
- 测试创建内核页表
- 测试映射所有必需区域
- 测试启用分页
- 测试启用后访问仍正常

## 五、关键技术细节

### PTE格式
```c
63       54 53       10  9  8  7  6  5  4  3  2  1  0
+----------+------------+--+--+--+--+--+--+--+--+--+
| Reserved |    PPN     | D| A| G| U| X| W| R| V|
+----------+------------+--+--+--+--+--+--+--+--+--+
           |  44位物理页号    |        权限位      |
```

**权限位含义**：
- `V` (Valid): 有效位
- `R` (Read): 可读
- `W` (Write): 可写
- `X` (eXecute): 可执行
- `U` (User): 用户模式
- `G` (Global): 全局
- `A` (Accessed): 已访问
- `D` (Dirty): 已修改

### 页表遍历算法
```c
pte_t* walk_create(pagetable_t pt, uint64_t va) {
    pagetable_t table = pt;
    
    // 从Level 2遍历到Level 1
    for (int level = 2; level > 0; level--) {
        int idx = VPN_MASK(va, level);
        pte_t pte = table[idx];
        
        if (有效 && 不是叶子) {
            // 进入下一级
            table = pte_to_table(pte);
        } else if (无效) {
            // 创建子页表
            child = alloc_pagetable_page();
            table[idx] = make_pte_for_table(child);
            table = child;
        } else {
            // 冲突：已是叶子映射
            return NULL;
        }
    }
    
    // 返回Level 0的PTE
    return &table[VPN_MASK(va, 0)];
}
```

## 六、讲解答题要点

### 如何解释物理内存管理器？
**关键点**：
1. 栈式设计：LIFO，简单高效
2. 静态池：64页预分配，避免动态管理
3. 安全检查：边界检查、对齐检查、重复释放检查

### 如何解释页表系统？
**关键点**：
1. 3级树结构：Level 2 -> Level 1 -> Level 0
2. 地址解析：9位VPN提取，12位偏移
3. 自动创建：walk_create按需创建中间表
4. 权限控制：通过PTE标志位设置

### 如何解释虚拟内存激活？
**关键点**：
1. 恒等映射：VA=PA，简化实现
2. 分段映射：代码(RX)、数据(RW)、设备(RW)
3. SATP设置：MODE=8启用Sv39
4. TLB刷新：sfence.vma使新设置生效

### 如何解释为什么能工作？
**关键点**：
1. **映射覆盖**：启用的所有内存区域都已映射
2. **恒等映射**：VA=PA，代码继续在相同地址执行
3. **权限匹配**：各段权限正确匹配用途
4. **TLB刷新**：确保新的页表立即生效

## 七、常见问题解答

**Q: 为什么分配了4个页而不是1个？**
A: Sv39需要3级页表。对于0x40000000需要：
- Level 2表（root）
- Level 1表  
- Level 0表
- 用户数据页
共计4个页面。

**Q: perm=0x6表示什么？**
A: 0x6 = 0b0110 = PTE_R(2) | PTE_W(4)。不含PTE_V表示这是测试输出的格式问题，实际应该包含V位。

**Q: 启用分页后为什么不会崩溃？**
A: 因为使用了恒等映射（VA=PA），所以相同地址继续指向相同的物理内存。代码执行逻辑完全相同。

**Q: walk_create和walk_lookup有什么区别？**
A: 
- `walk_create`: 用于建立映射，会创建不存在的中间页表
- `walk_lookup`: 用于查找映射，只读不创建，失败返回NULL

## 八、总结

实验3成功实现了：
1. ? 物理内存管理器：栈式分配，64页池
2. ? 页表管理系统：Sv39 3级页表，自动创建中间表
3. ? 虚拟内存激活：恒等映射，分段权限，SATP设置

**核心创新点**：
- 栈式PMM：简单高效
- 自动页表创建：walk_create按需分配
- 恒等映射策略：简化内核启动

代码包含详细注释，便于讲解和后续维护。

